# Білет №2

## 1. Основні рівні тестування (Unit, Integration, System, Acceptance)

### **Unit Testing (Модульне тестування)**:
- Перевіряється окремий модуль або функція програми.
- Тести ізольовані від решти системи; використовуються моки, стаби.
- Ціль: Перевірити, чи функціонує певний блок коду правильно.
- Інструменти: `unittest`, `pytest` (Python); `JUnit` (Java).

### **Integration Testing (Інтеграційне тестування)**:
- Перевіряє взаємодію між різними модулями (компонентами) системи.
- Ціль: Переконатися, що модулі коректно взаємодіють.
- Приклад: Тестування викликів API між мікросервісами.

### **System Testing (Системне тестування)**:
- Перевіряється вся система цілком, інтегрована і готова до використання.
- Ціль: Перевірити відповідність всіх функцій вимогам.
- Зазвичай включає тестування функціональності, продуктивності, безпеки.

### **Acceptance Testing (Приймальне тестування)**:
- Виконується замовником або кінцевим користувачем для схвалення продукту.
- Ціль: Переконатися, що система відповідає бізнес-вимогам.
- Приклади: Альфа- і бета-тестування.

---

## 2. Що таке покриття коду (Code Coverage)?

**Покриття коду (Code Coverage)** — це метрика, яка визначає, яка кількість вихідного коду була виконана під час тестування.

Інструменти, такі як `coverage.py`, створюють звіти, які показують:
1. Які рядки коду були виконані.
2. Які фрагменти залишилися неперевіреними.

### Як інтерпретувати результати звіту про покриття?
- **% покриття:** Відсоток рядків коду, які були виконані.
  - Наприклад, `80%` покриття означає, що 80% рядків коду були перевірені тести.
- **Важливість:** Високе покриття коду (напр., 90%+) зазвичай вказує на хороше тестування, але це не гарантує відсутності помилок.
- **Недоліки:** Можливе високе покриття з недостатньо якісними тестами, які не перевіряють межові випадки.

---

## 3. Яка роль систем контролю версій (наприклад, Git) у процесі колективної розробки та тестування?

Системи контролю версій, такі як Git, дозволяють командам розробників ефективно працювати над одним проектом. Їх функції:
1. **Відстеження змін:** Лог кожної зміни зберігається та може бути переглянутий.
2. **Колаборація:** Кілька розробників можуть працювати над різними частинами проекту одночасно.
3. **Гілкування:** Можливість створювати окремі гілки (`branches`) для нових функцій чи виправлення помилок.
4. **Код-рев'ю:** Функція pull request дозволяє команді переглянути код перед злиттям.
5. **Інтеграція з CI/CD:** Автоматизація тестів та перевірок перед злиттям коду гарантує стабільність.

---

## 4. Практична частина

### Завдання

Створити функцію `is_palindrome(text: str)`, яка перевіряє, чи є рядок паліндромом (читається однаково зліва направо і справа наліво), ігноруючи регістр тексту. 

Написати тести для перевірки:
- слів-паліндромів;
- слів, які не є паліндромами;
- пустих рядків (включаючи спеціальні випадки).

---

### Файл `main.py`
```python
def is_palindrome(text: str) -> bool:
    """
    Перевіряє, чи є рядок паліндромом.

    :param text: Вхідний рядок
    :return: True, якщо паліндром, інакше False
    """
    # Видаляємо пробіли та переводимо текст в нижній регістр
    normalized_text = ''.join(text.lower().split())
    # Порівнюємо рядок із його перевернутою версією
    return normalized_text == normalized_text[::-1]
```

---

### Файл `test.py`
```python
import unittest
from main import is_palindrome

class TestIsPalindrome(unittest.TestCase):
    def test_palindromes(self):
        # Тестуємо правильні паліндроми
        self.assertTrue(is_palindrome("Racecar"))
        self.assertTrue(is_palindrome("A man a plan a canal Panama"))
        self.assertTrue(is_palindrome("Madam"))

    def test_non_palindromes(self):
        # Тестуємо слова, які не є паліндромами
        self.assertFalse(is_palindrome("Hello"))
        self.assertFalse(is_palindrome("World"))
        self.assertFalse(is_palindrome("Python"))

    def test_empty_string(self):
        # Тестуємо випадки з пустими рядками
        self.assertTrue(is_palindrome(""))  # Пустий рядок — це теж паліндром
        self.assertTrue(is_palindrome(" "))  # Рядок із пробілом — паліндром

if __name__ == "__main__":
    unittest.main()
```
